# CS2053 -- Concept Assignment 1

## Due: 11:59pm, Jan. 28, 2022

## Instructions 
Write your answers the file below and commit and push, back up to GitHub, when you are finished. Simply type your answers in the space provide. You can edit this directly on GitHub if you like, too. If you need help with Markdown, see: <https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet>

## Questions 
Answer the following questions related to contents of Chapters 1 and 2 of the “Game Programming Algorithms and Techniques” book, the contents of our lecture and the contents of the Unity manual.

1. **Explain the difference between real time and game time.**

This is my answer to question 1.

2. **Provide pseudo-code similar to the pseudo code found in the book (and slides) for Pac Man but do it for the first level of the classic game Pong! See a video of [Pong! here](https://www.youtube.com/watch?v=it0sf4CMDeM) to remind yourself.**

THis is my answer to question 2.


3. **In Unity, describe the difference between the three different event functions: Update, FixedUpdate, and LastUpdate.**
   
  a. **What is the role of these three functions, when can they occur, and in what order?**
Answering questions 3 part a.

  b. **How do they relate to the game loop?**
 

  c. **Can we control how often each of these functions occur, and if so, how?**


4. **In 2D game graphics, explain why buffering is commonly used. Next, explain a reason why someone might want to disable buffering.**


5. **What advantage do sprite sheets have over individual sprites?**
 

6. **What is the difference between a tilemap and a tileset?**


7. **Image sequences of an animated sprite are usually contained in a single sprite sheet. In this case, in the data structure “AnimData” given in the textbook, array “ImageFile images[]” becomes a single variable “ImageFile image”. Modify the pseudocode (see code below) of  “AnimData” and “AnimatedSprite” to make the code work for a single sprite sheet instead of an array of images. Assume that images in the sprite sheet are stored on one horizontal dimension. You can update the provided code.**

```python

class Sprite
    ImageFile image
    int drawOrder
    int x, y
    function Draw()
        // Draw the image at the correct (x,y)
        ...
    end
end

SortedList spriteList
// When creating a new sprite...
Sprite newSprite = specify image and desired x/y
newSprite.drawOrder = set desired draw order value

// Add to sorted list based on draw order value
spriteList.Add(newSprite.drawOrder, newSprite)

// When it's time to draw...
foreach Sprite s in spriteList
    s.Draw()
loop

struct AnimFrameData
    // The index of the first frame of an animation
    int startFrame
    // The total number of frames for said animation
    int numFrames
end

struct AnimData
    // Array of images for all the animations
    ImageFile images[]

    // The frame data for all the different animations
    AnimFrameData frameInfo[]
end

class AnimatedSprite inherits Sprite
    // All of the animation data (includes ImageFiles and FrameData)
    AnimData animData

    // The particular animation that is active
    int animNum

    // The frame number of the active animation that's being displayed
    int frameNum

    // Amount of time the current frame has been displayed
    float frameTime
    
    // The FPS the animation is running at (24FPS by default).
    float animFPS = 24.0f
    
    function Initialize(AnimData myData, int startingAnimNum)
    function UpdateAnim(float deltaTime)
    function ChangeAnim(int num)
end

function AnimatedSprite.Initialize(AnimData myData, int startingAnimNum)
    animData = myData
    ChangeAnim(startingAnimNum)
end

function AnimatedSprite.ChangeAnim(int num)
    animNum = num

    // The active animation is now at frame 0 and 0.0f time
    frameNum = 0
    animTime = 0.0f

    // Set active image, which is just the starting frame.
    int imageNum = animData.frameInfo[animNum].startFrame
    image = animData.images[imageNum]
end

function AnimatedSprite.UpdateAnim(float deltaTime)
    // Update how long the current frame has been displayed
    frameTime += deltaTime

    // This check determines if it's time to change to the next frame.
    if frameTime > (1 / animFPS)

        // The number of frames to increment is the integral result of
        // frameTime / (1 / animFPS), which is frameTime * animFPS
        frameNum += frameTime * animFPS

        // Check if we've advanced past the last frame, and must wrap.
        if frameNum >= animData.frameInfo[animNum].numFrames
            // The modulus (%) makes sure we wrap correctly.

            // (Eg. If numFrames == 10 and frameNum == 11, frameNum would

            // wrap to 11 % 10 = 1).
            frameNum = frameNum % animData.frameInfo[animNum].numFrames
        end
        
        // Update the active image.
        // (startFrame is relative to all the images, while frameNum is
        // relative to the first frame of this particular animation).
        int imageNum = animData.frameInfo[animNum].startFrame + frameNum
        
        image = animData.images[imageNum]
        // We use fmod (floating point modulus) for the same reason
        // as the % above.
        frameTime = fmod(frameTime, 1 / animFPS)
    end
end

```
